p3.
UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节: 01010011，01100110，01110100。这些8比特字节和的反码是多少? ( 注意到尽管UDP和TCP使用16比特的字来计算检验和，但对于这个问题，你应该考虑8比特和。)写出所有工作过程。UDP为什么要用该和的反码，即为什么不直接使用该和呢?使用该反码方案，接收方如何检测出差错? 1比特的差错将可能检测不出来吗? 2比特的差错呢?
01010011
01100110
01110100
00101110
取反，11010001
采用反码方案不必依赖系统是大端还是小端
差错检验方法：将收到的数据与检验和相加，所得的结果如果有任一位为0，即为出错。
1比特的差错不可能检测不出，2比特的差错可能检测不出。
P6.考虑我们改正协议rdl2.1的动机。试说明如图3-57所示的接收方与如图3-11所示的发送方运行时，接收方可能会引起发送方和接收方进人死锁状态，即双方都在等待不可能发生的事件。
发送端重发依次0或1时接收端一直在等待正确的包，陷入死锁，
p40.
a.[1,6] [23,26]
b.[6,15] [17,22]
c.3个冗余ack
d.超时
e.32
f.21
g.14
h.7
i.ssthresh=4 cwnd=7
j.ssthresh=4 cwnd=4
k.52
